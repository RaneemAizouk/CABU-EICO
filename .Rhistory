# Clear workspace, remove all objects from the current environment
rm(list = ls())
setwd("/Users/raizouk/Desktop/R files")
# Source model functions, sources (loads) functions from the file named "Modified G Function.R"
source("./Modified G Function.R") # Control group function
source("./Modified G Function 2.R") # Intervention group function
#Pre-intervention,  the function "convert_to_state" takes the data frame "states_df" where each row in it represents a binary state composed of three binary digits (0 or 1)
#and convert  each row into a numeric state.
convert_to_state <- function(states_df) {
state_numeric <- apply(states_df, 1, function(states) {
state_str <- paste(states, collapse = "")
return(ifelse(state_str == "111", 7,
ifelse(state_str == "110", 6,
ifelse(state_str == "101", 5,
ifelse(state_str == "100", 4,
ifelse(state_str == "011", 3,
ifelse(state_str == "010", 2,
ifelse(state_str == "001", 1, 0))))))))
})
return(state_numeric)
}
# Post-intervention, the function "convert_to_state_m" takes the data frame "states_df_m" where each row in it represents a binary state composed of three binary digits (0 or 1)
# and convert  each row into a numeric state.
convert_to_state_m <- function(states_df_m) {
state_numeric_m <- apply(states_df_m, 1, function(states_m) {
state_str_m <- paste(states_m, collapse = "")
return(ifelse(state_str_m == "111", 7,
ifelse(state_str_m == "110", 6,
ifelse(state_str_m == "101", 5,
ifelse(state_str_m == "100", 4,
ifelse(state_str_m == "011", 3,
ifelse(state_str_m == "010", 2,
ifelse(state_str_m == "001", 1, 0))))))))
})
return(state_numeric_m)
}
# Define simulation parameters
tvec <- seq(0, 14, 1)
tmax <- max(tvec)
lambda1 <- 0.02 #before interventions.
lambda2 <- 0.03 #before interventions.
lambda3 <- 0.01 #after interventions (50% reduction).
lambda4 <- 0.015 # after interventions (50% reduction).
rho <- 0.05 # before interventions.
rho1 <- 0.06 #after interventions (20% increase).
current_states <- c(0, 1, 1)
# Initialize an empty list to store results
results_list <- list()
results_list_m <- list()
n.sims <- 1
n.clusters <- 12
houses_per_cluster <- 22
individuals_per_house <- 3
intervention_threshold <- 0.6
# Initialize named lists for better indexing
results_list <- list()
results_list_m <- list()
# Loop for simulations
for (sim in 1:n.sims) {
for (cluster in 1:n.clusters) {
for (house in 1:houses_per_cluster) {
# ASSIGN HOUSE ID
HouseID <- paste((cluster - 1) * houses_per_cluster + house, "_", sim)
# Randomly decide on the intervention status based on threshold
intervention_status <- ifelse(runif(1) <= intervention_threshold, 1, 0)
# Choose simulation function based on intervention status
if (intervention_status == 1) {
result_df <- gillespe1(lambda3, lambda4, rho1, current_states, tmax)
} else {
result_df <- gillespe(lambda1, lambda2, rho, current_states, tmax)
}
# Common processing for both scenarios
result_df$HouseID <- HouseID
result_df$simulation <- sim
result_df$intervention_status <- intervention_status
result_df <- result_df %>%
mutate(state_numeric = convert_to_state(select(., starts_with("X"))),
X1_individual_id = paste(HouseID, "1", sep="-"),
X2_individual_id = paste(HouseID, "2", sep="-"),
X3_individual_id = paste(HouseID, "3", sep="-"))
results_list[[length(results_list) + 1]] <- result_df
# Use HouseID as the key for direct access
# results_list[HouseID] <- result_df
}
}
}
# Load required packages using pacman for simplicity
if (!require(pacman)) {
install.packages("pacman")
}
# Ensure msmtools is installed
if (!requireNamespace("msmtools", quietly = TRUE)) {
install.packages("msmtools")
}
library(msmtools)
library(pacman)
p_load(viridis, adaptivetau, msm, tidyverse, ggplot2)
# Clear workspace, remove all objects from the current environment
rm(list = ls())
setwd("/Users/raizouk/Desktop/R files")
# Source model functions, sources (loads) functions from the file named "Modified G Function.R"
source("./Modified G Function.R") # Control group function
source("./Modified G Function 2.R") # Intervention group function
#Pre-intervention,  the function "convert_to_state" takes the data frame "states_df" where each row in it represents a binary state composed of three binary digits (0 or 1)
#and convert  each row into a numeric state.
convert_to_state <- function(states_df) {
state_numeric <- apply(states_df, 1, function(states) {
state_str <- paste(states, collapse = "")
return(ifelse(state_str == "111", 7,
ifelse(state_str == "110", 6,
ifelse(state_str == "101", 5,
ifelse(state_str == "100", 4,
ifelse(state_str == "011", 3,
ifelse(state_str == "010", 2,
ifelse(state_str == "001", 1, 0))))))))
})
return(state_numeric)
}
# Post-intervention, the function "convert_to_state_m" takes the data frame "states_df_m" where each row in it represents a binary state composed of three binary digits (0 or 1)
# and convert  each row into a numeric state.
convert_to_state_m <- function(states_df_m) {
state_numeric_m <- apply(states_df_m, 1, function(states_m) {
state_str_m <- paste(states_m, collapse = "")
return(ifelse(state_str_m == "111", 7,
ifelse(state_str_m == "110", 6,
ifelse(state_str_m == "101", 5,
ifelse(state_str_m == "100", 4,
ifelse(state_str_m == "011", 3,
ifelse(state_str_m == "010", 2,
ifelse(state_str_m == "001", 1, 0))))))))
})
return(state_numeric_m)
}
# Define simulation parameters
tvec <- seq(0, 14, 1)
tmax <- max(tvec)
lambda1 <- 0.02 #before interventions.
lambda2 <- 0.03 #before interventions.
lambda3 <- 0.01 #after interventions (50% reduction).
lambda4 <- 0.015 # after interventions (50% reduction).
rho <- 0.05 # before interventions.
rho1 <- 0.06 #after interventions (20% increase).
current_states <- c(0, 1, 1)
# Initialize an empty list to store results
results_list <- list()
results_list_m <- list()
n.sims <- 1
n.clusters <- 12
houses_per_cluster <- 22
individuals_per_house <- 3
intervention_threshold <- 0.6
# Initialize named lists for better indexing
results_list <- list()
results_list_m <- list()
# Loop for simulations
for (sim in 1:n.sims) {
for (cluster in 1:n.clusters) {
for (house in 1:houses_per_cluster) {
# ASSIGN HOUSE ID
HouseID <- paste((cluster - 1) * houses_per_cluster + house, "_", sim)
# Randomly decide on the intervention status based on threshold
intervention_status <- ifelse(runif(1) <= intervention_threshold, 1, 0)
# Choose simulation function based on intervention status
if (intervention_status == 1) {
result_df <- gillespe1(lambda3, lambda4, rho1, current_states, tmax)
} else {
result_df <- gillespe(lambda1, lambda2, rho, current_states, tmax)
}
# Common processing for both scenarios
result_df$HouseID <- HouseID
result_df$simulation <- sim
result_df$intervention_status <- intervention_status
result_df <- result_df %>%
mutate(state_numeric = convert_to_state(select(., starts_with("X"))),
X1_individual_id = paste(HouseID, "1", sep="-"),
X2_individual_id = paste(HouseID, "2", sep="-"),
X3_individual_id = paste(HouseID, "3", sep="-"))
results_list[[length(results_list) + 1]] <- result_df
# Use HouseID as the key for direct access
# results_list[HouseID] <- result_df
}
}
}
# Count data frames with only one row in post intervention part.
one_row_counts <- sapply(results_list_m, function(df) nrow(df) == 1)
# Sum up true values to get the total count
total_one_row_df = sum(one_row_counts)
# Assuming results_list is your list of results
desired_time_points <- c(3, 6, 9, 12)
View(results_list)
#The code uses simulation techniques and statistical
#modelling to evaluate the effects of public health
#interventions on disease dynamics in a population.
#It simulates transmission events before and after interventions,
#providing insights into potential shifts in disease spread patterns.
#The Gillespie algorithm is used in the pre-intervention phase to model random
#and variable probabilities of events where it uses parameters
#like transmission rates (lambda1 and lambda2) and recovery rate (rho)
#to mirror the baseline dynamics of disease spread within the population.
#In the post-intervention phase, a modified version of the algorithm is used to
#simulate the impact of intervention strategies. This adaptation adjusts the parameters to
#reflect anticipated changes due to interventions—namely, a 50% reduction in transmission rates (lambda3 and lambda4)
#and a 20% increase in the recovery rate (rho1).
# Load required packages using pacman for simplicity
if (!require(pacman)) {
install.packages("pacman")
}
# Ensure msmtools is installed
if (!requireNamespace("msmtools", quietly = TRUE)) {
install.packages("msmtools")
}
library(msmtools)
library(pacman)
p_load(viridis, adaptivetau, msm, tidyverse, ggplot2)
# Clear workspace, remove all objects from the current environment
rm(list = ls())
setwd("/Users/raizouk/Desktop/R files")
# Source model functions, sources (loads) functions from the file named "Modified G Function.R"
source("./Modified G Function.R") # Control group function
source("./Modified G Function 2.R") # Intervention group function
#Pre-intervention,  the function "convert_to_state" takes the data frame "states_df" where each row in it represents a binary state composed of three binary digits (0 or 1)
#and convert  each row into a numeric state.
convert_to_state <- function(states_df) {
state_numeric <- apply(states_df, 1, function(states) {
state_str <- paste(states, collapse = "")
return(ifelse(state_str == "111", 7,
ifelse(state_str == "110", 6,
ifelse(state_str == "101", 5,
ifelse(state_str == "100", 4,
ifelse(state_str == "011", 3,
ifelse(state_str == "010", 2,
ifelse(state_str == "001", 1, 0))))))))
})
return(state_numeric)
}
# Post-intervention, the function "convert_to_state_m" takes the data frame "states_df_m" where each row in it represents a binary state composed of three binary digits (0 or 1)
# and convert  each row into a numeric state.
convert_to_state_m <- function(states_df_m) {
state_numeric_m <- apply(states_df_m, 1, function(states_m) {
state_str_m <- paste(states_m, collapse = "")
return(ifelse(state_str_m == "111", 7,
ifelse(state_str_m == "110", 6,
ifelse(state_str_m == "101", 5,
ifelse(state_str_m == "100", 4,
ifelse(state_str_m == "011", 3,
ifelse(state_str_m == "010", 2,
ifelse(state_str_m == "001", 1, 0))))))))
})
return(state_numeric_m)
}
# Define simulation parameters
tvec <- seq(0, 14, 1)
tmax <- max(tvec)
lambda1 <- 0.02 #before interventions.
lambda2 <- 0.03 #before interventions.
lambda3 <- 0.01 #after interventions (50% reduction).
lambda4 <- 0.015 # after interventions (50% reduction).
rho <- 0.05 # before interventions.
rho1 <- 0.06 #after interventions (20% increase).
current_states <- c(0, 1, 1)
# Initialize an empty list to store results
results_list <- list()
results_list_m <- list()
n.sims <- 1
n.clusters <- 12
houses_per_cluster <- 22
individuals_per_house <- 3
intervention_threshold <- 0.6
# Initialize named lists for better indexing
results_list <- list()
results_list_m <- list()
# Loop for simulations
for (sim in 1:n.sims) {
for (cluster in 1:n.clusters) {
for (house in 1:houses_per_cluster) {
# ASSIGN HOUSE ID
HouseID <- paste((cluster - 1) * houses_per_cluster + house, "_", sim)
# Randomly decide on the intervention status based on threshold
intervention_status <- ifelse(runif(1) <= intervention_threshold, 1, 0)
# Choose simulation function based on intervention status
if (intervention_status == 1) {
result_df <- gillespe1(lambda3, lambda4, rho1, current_states, tmax)
} else {
result_df <- gillespe(lambda1, lambda2, rho, current_states, tmax)
}
# Common processing for both scenarios
result_df$HouseID <- HouseID
result_df$simulation <- sim
result_df$intervention_status <- intervention_status
result_df <- result_df %>%
mutate(state_numeric = convert_to_state(select(., starts_with("X"))),
X1_individual_id = paste(HouseID, "1", sep="-"),
X2_individual_id = paste(HouseID, "2", sep="-"),
X3_individual_id = paste(HouseID, "3", sep="-"))
results_list[[length(results_list) + 1]] <- result_df
# Use HouseID as the key for direct access
# results_list[HouseID] <- result_df
}
}
# Load required packages using pacman for simplicity
if (!require(pacman)) {
install.packages("pacman")
}
# Ensure msmtools is installed
if (!requireNamespace("msmtools", quietly = TRUE)) {
install.packages("msmtools")
}
library(msmtools)
library(pacman)
p_load(viridis, adaptivetau, msm, tidyverse, ggplot2)
# Clear workspace, remove all objects from the current environment
rm(list = ls())
setwd("/Users/raizouk/Desktop/R files")
# Source model functions, sources (loads) functions from the file named "Modified G Function.R"
source("./Modified G Function.R") # Control group function
source("./Modified G Function 2.R") # Intervention group function
#Pre-intervention,  the function "convert_to_state" takes the data frame "states_df" where each row in it represents a binary state composed of three binary digits (0 or 1)
#and convert  each row into a numeric state.
convert_to_state <- function(states_df) {
state_numeric <- apply(states_df, 1, function(states) {
state_str <- paste(states, collapse = "")
return(ifelse(state_str == "111", 7,
ifelse(state_str == "110", 6,
ifelse(state_str == "101", 5,
ifelse(state_str == "100", 4,
ifelse(state_str == "011", 3,
ifelse(state_str == "010", 2,
ifelse(state_str == "001", 1, 0))))))))
})
return(state_numeric)
}
# Post-intervention, the function "convert_to_state_m" takes the data frame "states_df_m" where each row in it represents a binary state composed of three binary digits (0 or 1)
# and convert  each row into a numeric state.
convert_to_state_m <- function(states_df_m) {
state_numeric_m <- apply(states_df_m, 1, function(states_m) {
state_str_m <- paste(states_m, collapse = "")
return(ifelse(state_str_m == "111", 7,
ifelse(state_str_m == "110", 6,
ifelse(state_str_m == "101", 5,
ifelse(state_str_m == "100", 4,
ifelse(state_str_m == "011", 3,
ifelse(state_str_m == "010", 2,
ifelse(state_str_m == "001", 1, 0))))))))
})
return(state_numeric_m)
}
# Define simulation parameters
tvec <- seq(0, 14, 1)
tmax <- max(tvec)
lambda1 <- 0.02 #before interventions.
lambda2 <- 0.03 #before interventions.
lambda3 <- 0.01 #after interventions (50% reduction).
lambda4 <- 0.015 # after interventions (50% reduction).
rho <- 0.05 # before interventions.
rho1 <- 0.06 #after interventions (20% increase).
current_states <- c(0, 1, 1)
# Initialize an empty list to store results
results_list <- list()
results_list_m <- list()
n.sims <- 1
n.clusters <- 12
houses_per_cluster <- 22
individuals_per_house <- 3
intervention_threshold <- 0.6
# Initialize named lists for better indexing
results_list <- list()
results_list_m <- list()
# Loop for simulations
for (sim in 1:n.sims) {
for (cluster in 1:n.clusters) {
for (house in 1:houses_per_cluster) {
# ASSIGN HOUSE ID
HouseID <- paste((cluster - 1) * houses_per_cluster + house, "_", sim)
# Randomly decide on the intervention status based on threshold
intervention_status <- ifelse(runif(1) <= intervention_threshold, 1, 0)
# Choose simulation function based on intervention status
if (intervention_status == 1) {
result_df <- gillespe1(lambda3, lambda4, rho1, current_states, tmax)
} else {
result_df <- gillespe(lambda1, lambda2, rho, current_states, tmax)
}
# Common processing for both scenarios
result_df$HouseID <- HouseID
result_df$simulation <- sim
result_df$intervention_status <- intervention_status
result_df <- result_df %>%
mutate(state_numeric = convert_to_state(select(., starts_with("X"))),
X1_individual_id = paste(HouseID, "1", sep="-"),
X2_individual_id = paste(HouseID, "2", sep="-"),
X3_individual_id = paste(HouseID, "3", sep="-"))
results_list[[length(results_list) + 1]] <- result_df
# Use HouseID as the key for direct access
# results_list[HouseID] <- result_df
}
}
}
# Count data frames with only one row in post intervention part.
one_row_counts <- sapply(results_list_m, function(df) nrow(df) == 1)
# Sum up true values to get the total count
total_one_row_df = sum(one_row_counts)
# Assuming results_list is your list of results
desired_time_points <- c(3, 6, 9, 12)
#The code uses simulation techniques and statistical
#modelling to evaluate the effects of public health
#interventions on disease dynamics in a population.
#It simulates transmission events before and after interventions,
#providing insights into potential shifts in disease spread patterns.
#The Gillespie algorithm is used in the pre-intervention phase to model random
#and variable probabilities of events where it uses parameters
#like transmission rates (lambda1 and lambda2) and recovery rate (rho)
#to mirror the baseline dynamics of disease spread within the population.
#In the post-intervention phase, a modified version of the algorithm is used to
#simulate the impact of intervention strategies. This adaptation adjusts the parameters to
#reflect anticipated changes due to interventions—namely, a 50% reduction in transmission rates (lambda3 and lambda4)
#and a 20% increase in the recovery rate (rho1).
# Load required packages using pacman for simplicity
if (!require(pacman)) {
install.packages("pacman")
}
# Ensure msmtools is installed
if (!requireNamespace("msmtools", quietly = TRUE)) {
install.packages("msmtools")
}
library(msmtools)
library(pacman)
p_load(viridis, adaptivetau, msm, tidyverse, ggplot2)
# Clear workspace, remove all objects from the current environment
rm(list = ls())
setwd("/Users/raizouk/Desktop/R files")
# Source model functions, sources (loads) functions from the file named "Modified G Function.R"
source("./Modified G Function.R") # Control group function
source("./Modified G Function 2.R") # Intervention group function
#Pre-intervention,  the function "convert_to_state" takes the data frame "states_df" where each row in it represents a binary state composed of three binary digits (0 or 1)
#and convert  each row into a numeric state.
convert_to_state <- function(states_df) {
state_numeric <- apply(states_df, 1, function(states) {
state_str <- paste(states, collapse = "")
return(ifelse(state_str == "111", 7,
ifelse(state_str == "110", 6,
ifelse(state_str == "101", 5,
ifelse(state_str == "100", 4,
ifelse(state_str == "011", 3,
ifelse(state_str == "010", 2,
ifelse(state_str == "001", 1, 0))))))))
})
return(state_numeric)
}
# Post-intervention, the function "convert_to_state_m" takes the data frame "states_df_m" where each row in it represents a binary state composed of three binary digits (0 or 1)
# and convert  each row into a numeric state.
convert_to_state_m <- function(states_df_m) {
state_numeric_m <- apply(states_df_m, 1, function(states_m) {
state_str_m <- paste(states_m, collapse = "")
return(ifelse(state_str_m == "111", 7,
ifelse(state_str_m == "110", 6,
ifelse(state_str_m == "101", 5,
ifelse(state_str_m == "100", 4,
ifelse(state_str_m == "011", 3,
ifelse(state_str_m == "010", 2,
ifelse(state_str_m == "001", 1, 0))))))))
})
return(state_numeric_m)
}
# Define simulation parameters
tvec <- seq(0, 14, 1)
tmax <- max(tvec)
lambda1 <- 0.02 #before interventions.
lambda2 <- 0.03 #before interventions.
lambda3 <- 0.01 #after interventions (50% reduction).
lambda4 <- 0.015 # after interventions (50% reduction).
rho <- 0.05 # before interventions.
rho1 <- 0.06 #after interventions (20% increase).
current_states <- c(0, 1, 1)
# Initialize an empty list to store results
results_list <- list()
results_list_m <- list()
n.sims <- 1
n.clusters <- 12
houses_per_cluster <- 22
individuals_per_house <- 3
intervention_threshold <- 0.6
# Initialize named lists for better indexing
results_list <- list()
results_list_m <- list()
# Loop for simulations
for (sim in 1:n.sims) {
for (cluster in 1:n.clusters) {
for (house in 1:houses_per_cluster) {
# ASSIGN HOUSE ID
HouseID <- paste((cluster - 1) * houses_per_cluster + house, "_", sim)
# Randomly decide on the intervention status based on threshold
intervention_status <- ifelse(runif(1) <= intervention_threshold, 1, 0)
# Choose simulation function based on intervention status
if (intervention_status == 1) {
result_df <- gillespe1(lambda3, lambda4, rho1, current_states, tmax)
} else {
result_df <- gillespe(lambda1, lambda2, rho, current_states, tmax)
}
# Common processing for both scenarios
result_df$HouseID <- HouseID
result_df$simulation <- sim
result_df$intervention_status <- intervention_status
result_df <- result_df %>%
mutate(state_numeric = convert_to_state(select(., starts_with("X"))),
X1_individual_id = paste(HouseID, "1", sep="-"),
X2_individual_id = paste(HouseID, "2", sep="-"),
X3_individual_id = paste(HouseID, "3", sep="-"))
results_list[[length(results_list) + 1]] <- result_df
# Use HouseID as the key for direct access
# results_list[HouseID] <- result_df
}
}
}
